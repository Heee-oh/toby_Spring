트랜잭션 경계설정
- 오토커밋을 끄고, 트랜잭션의 시작을 선언, commit, rollback으로 트랜잭션을 종료하는 작업
- 하나의 connection이 만들어지고 닫히는 범위 안에 존재한다.
- 하나의 DB 커넥션 안에서 만들어지는 트랜잭션 : 로컬 트랜잭션


### 트랜잭션 동기화 저장소
트랜잭션 시작을 위해 만든 Connection 객체를 특별한 저장소에 보관해두고, 필요시 꺼내 씀

트랜잭션 동기화 저장소에 커넥션 확인, 없다면 생성후 저장
있다면 dao에 접근해서 SQL 작업 수행
작업이 끝나면 트랜잭션 커넥션에 커밋 호출
끝나면 커넥션 삭제

스레드 마다 독립적으로 커넥션이 저장 및 관리됨 (충돌 X)

### 일반적으로 PlatformTransactionManager 을 표준인터페이스로 사용
- JDBC(Connection), JTA(UserTransaction), Hibernate(Transaction) 등 기술마다 트랜잭션 제어 코드가 다름
- 이를 하나로 통합하여 서비스 코드가 특정 기술 의존성 제거하려 도입
```text
getTransaction() : 트랜잭션 시작
commit() : 성공시 확정
rollback() : 실패시 취소
```
```java


PlatformTransactionManager transactionManager;
UserDao userDao;

// 1단계: 주문서 준비 (어떤 트랜잭션을 원하는지?)
DefaultTransactionDefinition def = new DefaultTransactionDefinition();
// 트랜잭션 전파 수준 설정
def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

// 2, 3, 4단계: 매니저를 통해 트랜잭션 시작 및 영수증(status) 획득
// 내부적으로 커넥션을 생성하고 '트랜잭션 동기화 저장소'에 묶어둡니다.
TransactionStatus status = transactionManager.getTransaction(def);

try {
    // 5단계: 비즈니스 로직 실행
    // 여기서 호출되는 DAO들은 '동기화 저장소'에서 아까 만든 커넥션을 자동으로 꺼내 씁니다.
        
    userDao.update(user1);
    userDao.update(user2);

    // 6단계 (성공): 영수증을 제출하며 "문제없으니 확정해줘" 요청
    transactionManager.commit(status);
} catch (RuntimeException e) {
    // 6단계 (실패): 영수증을 제출하며 "문제 생겼으니 다 취소해줘" 요청
    transactionManager.rollback(status);
    throw e;
}
```


### JPA 전용 매니저
spring-boot-starter-data-jpa 의존성을 추가시
스프링 부트가 JpaTransactionManager를 빈(Bean)으로 등록
JpaTransactionManager가 표준이기에
하이버네이트도 포함, 일반 JDBC(MyBatis) 등도 이거 하나로 사용가능
